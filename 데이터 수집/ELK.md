# 로그 (Log)
- 컴퓨터가 수행하는 도중 유의미한 내용을 파일로 남기는 기록

## 로그의 내용
- 다음 4가지는 필수적으로 포함되어야 한다.
  - 로그 시간
  - 로그 레벨
    - 심각성의 정도를 의미한다.
    - 종류
      - `TRACE`: 어플리케이션에서 어떤 내용이 일어나는지 상세하고 보고 싶을 때 사용
      - `DEBUG`: 디버깅 용도로 남기는 로그 (개발 단계에서의 유의미한 정보)
      - `INFO`: 짤막하게 간단한 단순 정보를 남기는 로그 (가장 많이 볼 로그)
      - `WARN`: 동작에는 상관이 없지만 반복해서 나타나는 자잘한 오류
      - `ERROR`: 시스템이 정지될 수 있는 오류, 반드시 개발자가 해결해야 한다.
      - `FATAL`: 하드웨어에 큰 문제가 생겼을 때 나타나는 에러
  - 로그 내용
  - 로그 발생 위치
    - 로그를 남긴 패키지, 클래스의 정보는 필수로 저장해야 한다.
    - 일반적으로 웹서비스라면 url이 나타난다.
- 하나를 제외해야 한다고 하면, 로그 레벨이 제외된다. (그래도 웬만하면 넣는게 좋다)

## 로그를 수집하는 이유
- 시스템 장애 시 로그 파일에 다시 접속하기 어려울 수 있다.
- 로그를 확인할 때 일일히 서비스마다 찾아야 하는게 번거로운 작업이다.
  - 예를 들어, 조그마한 서비스를 모아 거대한 서비스 하나를 제공하는 것(ex 카카오톡), 즉 MSA는 하나하나 서비스를 방문해야 한다.
- 이러한 로그를 수집해서 하나의 저장소에 모아놓는 역할을 하는게 바로 ELK 스택이다.

# 로그 수집 아키텍쳐파일을 이용한 수집
- 어플리케이션에서는 로그를 파일로만 남기기 때문에, 별도로 파일로부터 로그를 수집해서 전송하는 프로세스를 만들어서 활용한다.
- 이 경우 디스크에 로그 파일이 남겨진다.
- 장점
  - 어플리케이션과 로그 수집기가 **관심사의 분리**가 된다.
    - 관심사의 분리(SoC: Separation of Concerns): 개발자에게는 성배와 같은 원리. 어떤 구체적인 목적이 있다고 가정하자. A, B가 같이 들어가야 하나의 목적이 달성되는 경우다. 두 개는 서로 의존하지 않는 것처럼 보이지만 둘 모두 작동이 잘 되어야만 원하는 목적한 바를 이룰 수있다. A와 B라는 프로그램의 관심사는 개개의 A와 B 프로그램이 잘 작동하는데 의의가 있다. 그렇지만 A, B가 각자 작동을 하고 보니 목적이 잘 이루어지고 있는 상태가 된다. 즉 여러 개의 프로그램이 각자 할 일을 잘 수행하고, 이로 인해 궁극적인 하나의 목적이 달성되는 것을 의마한다.( 소프트웨어 공학 기법 중 하나)
  - 컨테이너 환경을 이용해서 어플리케이션과 수집기의 리소스 분리 => 컴퓨터를 분리하면, 수집기 때문에 어플리케이션에 부하를 주지 않는다.
- 단점
  - 어플리케이션과 로그 수집기를 별도로 관리해야 한다.
    - 로그 콜렉터가 로그 파일을 제대로 못 가져갔다면, DB는 어플리케이션에서 로그를 망가졌다고 오해할 수 있다.

## Network를 이용한 Push
- 어플리케이션에서 직접 로그수집기로 (TCP, HTTP 등의 프로토콜을 이용해서) 로그를 전송한다.
- 장점
  - 로그 전송의 성공 실패 여부를 어플리케이션에서 판단할 수 있다.
- 단점
  - 어플리케이션 로직과 로그 전송을 같은 프로세스에서 수행하므로 서로 영향을 미칠 수 있다. (관심사의 분리가 포기될 수 있다.)
  - 로그 전송 때문에 어플리케이션 부하나 병목 현상이 있을 수 있다.
    - 도로 3차선에서 2차선으로 바뀌는 것과 같다. 요청은 많은데 처리할 수 있는 자원이 작은 상황이다.
  - 문제 디버깅이 복잡해진다.

## Network를 이용한 Polling
- 어플리케이션이 Network Port, path만 열어두고, 수집기에서 주기적으로 Polling으로 스크랩하는 방식이다.
  - Network Port, path == 시스템의 정보, 로그 정보 등에 대해 스크랩 할 수 있는 채널
  - 로그보다는 Metirc(통계 정보, 상태 정보 등) 수집에 더 적합하다.
- 어플리케이션과 로그수집기 사이에 Log Collector가 위치하여 주기적으로 Polling 한다.
- 이전에는 로그 파일에서 가져갔었다면, 이제는 Log Collector가 어플리케이션에 요청하고 로그 수집기가 로그를 직접 가져가는 것(크롤링)으로, Push 방법과 반대된다.
- 사용하고 있는 웹서버의 데이터를 스크래핑하기 때문에 시스템의 현재 상황에 대해 지속적으로 모니터링이 필요하다.
- 장점
  - 어플리케이션과 매트릭 수집에 대한 관심사의 분리가 이루어진다.
  - 분산 환경, 컨테이너 환경, 자동화된 인프라 환경에서 사용성이 편하고 확장성이 높다.
- 단점
  - 급격한 상황에 대한 즉각적인 대처는 어렵다.

# EFK 로그 수집 아키텍쳐
- ElasticSearch, Fluentd, Kibana의 앞글자를 따서 EFK(ELK)라고 한다.
  - Elastic stack으로 구성된 ELK(L=Logstash)라는 용어가 주로 사용된다.
  - Elastic stack의 유료화로 인해 Opensearch(ElasticSearch), Fluentd, Opendashboard(Kibana) 구성을 사용한다.
- 웹서비스를 만들어서 로그분석을 한다고 하면 ELK 내용에서 거의 벗어나지 않는다.

## Fluentd
- EFK에서 수집을 담당한다.
- 수집(가져와서) 파싱(처리하고) 전송(원하는 곳으로 전달)까지 하는 게 역할
- 가장 어려우면서 신경써야 하는 부분은 parsing이다.
- 적은 리소스를 파싱하고 전송하는데 특화되어있다.
- 규칙을 태그방식으로 정하기 때문에 직관적이다.
- 거의 대부분 문자열화된 로그를 json 형태로 바꾸는 게 대부분이다.
  - 로그를 쉽게 쌓을려면 애초에 로그를 쌓을 때 json 모양으로 쌓는게 가장 좋다. (강추)

## Opensearch(Elasticsearch)
- ELK에서 로그 저장을 담당한다.
- 로그를 저장하는 저장소로, Opensearch의 경우 텍스트 검색에 특화되어 있다.
  - RDBMS는 PK에 의한 조회, 인덱싱, 조인, 그룹바이같은 데이터 가공에 특화되어 있다면, Opensearch는 일반적인 텍스트 데이터의 저장소 겸 검색 시스템에 특화되어 있다.
  - 에브리타임이라는 단어를 에타, ㅇㅂㄹㅌㅇ과 같이 검색해도 나타나게 하는 텍스트 처리가 가능하다.
- 자바로 만들어졌으며, JVM 위에서 동작한다.

## Open dashboard
- ELK에서 로그의 시각화를 담당한다.
- 대부분 Opensearch와 연동되어 함께 움직인다. 
- Opensearch로부터 데이터를 받아 시각화 하는 역할을 수행하며, 많은 기업에서 ELK 스택의 모니터링에 굉장히 많이 사용한다.
- Open dashboard를 이용한 군집 등을 사용해서 ML을 할 수 있다.
- 검색 결과에 대한 링크를 생성해서 빠르게 공유할 수 있으며, SQL을 모르더라도 원하는 로그를 쉽게 찾아 확인할 수 있다.
  - share 버튼에서 permalink로 공유 가능하다.
  - 실시간 현황을 보려면 embed coad로 공유할 수 있다. → <iframe> 코드가 생성돼서 html 프론트엔드에 넣으면 웹에 대시보드 띄울수 있다.

# 요구 사항에 따른 구성 방법
- 하나 혹은 여러 컴퓨터에서 데이터를 모은후 ElasticSearch에서 쓸 수 있다.
- 작은 규모의 서비스같은 경우에는 수집기(Fluentd)에서 바로 저장소(Opensearch)로 전송되는 것이 좋다. 구성이 단순하고 비용이 적다.
  - 실습의 경우 해당 수준의 기본 아키택쳐 정도만 해도 훌륭한 수준이다.
- 부하가 있을때는 로그가 유실될 수 있으니 대책이 필요하다.

# 실습
- Fluentd로 로그를 파싱하고 보내기
- Opensearch(ElasticSearch)로 로그 저장하기
- Open Dashboard(Kibana)로 로그 시각화하기